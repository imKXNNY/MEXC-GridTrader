
# Generated by Qodo Gen
from src.data_handler.live_data_websocket import LiveDataWebSocketHandler

import websocket
import json
# Dependencies:
# pip install pytest-mock
import pytest

class TestLiveDataWebSocketHandler:

    # WebSocket successfully connects and receives messages for subscribed symbols
    def test_websocket_connects_and_receives_messages(self, mocker):
        # Arrange
        symbols = ['BTC/USDT']
        handler = LiveDataWebSocketHandler(symbols)
        mock_ws = mocker.Mock()

        # Configure the mock so it has the same references
        mock_ws.configure_mock(
            run_forever=mocker.Mock(),
            on_message=handler.on_message,
            on_error=handler.on_error,
            on_close=handler.on_close
        )

        # Patch the correct path
        mocker.patch(
            'src.data_handler.live_data_websocket.websocket.WebSocketApp',
            return_value=mock_ws
        )

        # Act
        handler.run()

        # Assert
        mock_ws.run_forever.assert_called_once()
        assert handler.ws is not None
        assert handler.ws.on_message == handler.on_message
        assert handler.ws.on_error == handler.on_error
        assert handler.ws.on_close == handler.on_close

    # Multiple symbols can be subscribed to via on_open handler
    def test_multiple_symbol_subscription(self, mocker):
        # Arrange
        symbols = ['BTC/USDT', 'ETH/USDT']
        handler = LiveDataWebSocketHandler(symbols)
        mock_ws = mocker.Mock()
    
        # Act
        handler.on_open(mock_ws)
    
        # Assert
        assert mock_ws.send.call_count == 2
    
        # Verify subscription messages
        expected_messages = [
            json.dumps({
                "method": "SUBSCRIBE",
                "params": ["btc/usdt@ticker"],
                "id": 1
            }),
            json.dumps({
                "method": "SUBSCRIBE", 
                "params": ["eth/usdt@ticker"],
                "id": 1
            })
        ]
    
        actual_calls = [call_args[0][0] for call_args in mock_ws.send.call_args_list]
        assert sorted(actual_calls) == sorted(expected_messages)

    # Handle invalid JSON messages from WebSocket
    def test_handle_invalid_json_message(self, mocker):
        handler = LiveDataWebSocketHandler(['BTC/USDT'])
        mock_ws = mocker.Mock()
        invalid_message = "invalid json"

        # Patch the EXACT logger reference
        mock_logger = mocker.patch('src.data_handler.live_data_websocket.logger')

        handler.on_message(mock_ws, invalid_message)

        # Now we see the error call
        mock_logger.error.assert_called_once()
        assert "JSONDecodeError" in str(mock_logger.error.call_args[0])

    # Handle network disconnection and reconnection scenarios
    def test_handle_network_disconnection(self, mocker):
        handler = LiveDataWebSocketHandler(['BTC/USDT'])
        mock_ws = mocker.Mock()
        mock_logger = mocker.patch('src.data_handler.live_data_websocket.logger')

        network_error = websocket.WebSocketConnectionClosedException()

        handler.on_error(mock_ws, network_error)
        handler.on_close(mock_ws)

        mock_logger.error.assert_called_once_with("WebSocket error: %s", network_error)
        mock_logger.info.assert_called_with("WebSocket closed")